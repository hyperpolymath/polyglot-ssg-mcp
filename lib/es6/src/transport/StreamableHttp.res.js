// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Http from "../bindings/Http.res.js";
import * as Stdlib_Dict from "@rescript/runtime/lib/es6/Stdlib_Dict.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

let protocolVersion = "2025-06-18";

let LogLevel = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
};

let currentLogLevel = {
  contents: 1
};

function setLogLevel(level) {
  currentLogLevel.contents = level;
}

function log(level, message, context) {
  if (level < currentLogLevel.contents) {
    return;
  }
  let levelName;
  switch (level) {
    case 0 :
      levelName = "DEBUG";
      break;
    case 1 :
      levelName = "INFO";
      break;
    case 2 :
      levelName = "WARN";
      break;
    default:
      levelName = "ERROR";
  }
  let entry = {};
  entry["timestamp"] = new Date().toISOString();
  entry["level"] = levelName;
  entry["message"] = message;
  if (context !== undefined) {
    entry["context"] = context;
  }
  console.error(JSON.stringify(entry));
}

function makeCircuitBreaker(failureThresholdOpt, resetTimeoutMsOpt, halfOpenRequestsOpt, param) {
  let failureThreshold = failureThresholdOpt !== undefined ? failureThresholdOpt : 5;
  let resetTimeoutMs = resetTimeoutMsOpt !== undefined ? resetTimeoutMsOpt : 30000;
  let halfOpenRequests = halfOpenRequestsOpt !== undefined ? halfOpenRequestsOpt : 1;
  return {
    state: "Closed",
    failures: 0,
    lastFailureTime: undefined,
    halfOpenAttempts: 0,
    config: {
      failureThreshold: failureThreshold,
      resetTimeoutMs: resetTimeoutMs,
      halfOpenRequests: halfOpenRequests
    }
  };
}

function canExecute(cb) {
  let match = cb.state;
  switch (match) {
    case "Closed" :
      return true;
    case "Open" :
      let lastTime = cb.lastFailureTime;
      if (lastTime !== undefined && Date.now() - lastTime > cb.config.resetTimeoutMs) {
        cb.state = "HalfOpen";
        cb.halfOpenAttempts = 0;
        log(1, "Circuit breaker transitioning to HALF_OPEN", undefined);
        return true;
      } else {
        return false;
      }
    case "HalfOpen" :
      return cb.halfOpenAttempts < cb.config.halfOpenRequests;
  }
}

function recordSuccess(cb) {
  if (cb.state === "HalfOpen") {
    log(1, "Circuit breaker closing after successful request", undefined);
  }
  cb.failures = 0;
  cb.state = "Closed";
  cb.halfOpenAttempts = 0;
}

function recordFailure(cb) {
  cb.failures = cb.failures + 1 | 0;
  cb.lastFailureTime = Date.now();
  if (cb.state === "HalfOpen") {
    cb.halfOpenAttempts = cb.halfOpenAttempts + 1 | 0;
  }
  if (cb.failures < cb.config.failureThreshold) {
    return;
  }
  cb.state = "Open";
  let ctx = {};
  ctx["failures"] = cb.failures;
  log(2, "Circuit breaker OPEN", ctx);
}

function getCircuitState(cb) {
  let result = {};
  let match = cb.state;
  let stateStr;
  switch (match) {
    case "Closed" :
      stateStr = "CLOSED";
      break;
    case "Open" :
      stateStr = "OPEN";
      break;
    case "HalfOpen" :
      stateStr = "HALF_OPEN";
      break;
  }
  result["state"] = stateStr;
  result["failures"] = cb.failures;
  return result;
}

function makeRateLimiter(windowMsOpt, maxRequestsOpt, param) {
  let windowMs = windowMsOpt !== undefined ? windowMsOpt : 60000;
  let maxRequests = maxRequestsOpt !== undefined ? maxRequestsOpt : 100;
  return {
    config: {
      windowMs: windowMs,
      maxRequests: maxRequests
    },
    requests: {}
  };
}

function isAllowed(rl, sessionId) {
  let now = Date.now();
  let windowStart = now - rl.config.windowMs;
  let ts = rl.requests[sessionId];
  let timestamps = ts !== undefined ? ts.filter(t => t > windowStart) : [];
  if (timestamps.length >= rl.config.maxRequests) {
    return false;
  }
  let newTimestamps = timestamps.concat([now]);
  rl.requests[sessionId] = newTimestamps;
  return true;
}

function cleanupRateLimiter(rl) {
  let now = Date.now();
  let windowStart = now - rl.config.windowMs;
  let keys = Object.keys(rl.requests);
  keys.forEach(sessionId => {
    let timestamps = rl.requests[sessionId];
    if (timestamps === undefined) {
      return;
    }
    let valid = timestamps.filter(t => t > windowStart);
    if (valid.length === 0) {
      return Stdlib_Dict.$$delete(rl.requests, sessionId);
    } else {
      rl.requests[sessionId] = valid;
      return;
    }
  });
}

function makeSessionStore(ttlMsOpt, param) {
  let ttlMs = ttlMsOpt !== undefined ? ttlMsOpt : 1800000;
  return {
    sessions: {},
    ttlMs: ttlMs
  };
}

function createSession(store) {
  let sessionId = Http.generateSessionId();
  let now = Date.now();
  let session = {
    id: sessionId,
    createdAt: now,
    lastAccess: now,
    initialized: false,
    pendingMessages: [],
    eventCounter: 0,
    requestCount: 0,
    errorCount: 0
  };
  store.sessions[sessionId] = session;
  let ctx = {};
  ctx["sessionId"] = sessionId;
  log(0, "Session created", ctx);
  return session;
}

function getSession(store, sessionId) {
  let session = store.sessions[sessionId];
  if (session !== undefined) {
    session.lastAccess = Date.now();
    return session;
  }
}

function deleteSession(store, sessionId) {
  let ctx = {};
  ctx["sessionId"] = sessionId;
  log(0, "Session deleted", ctx);
  Stdlib_Dict.$$delete(store.sessions, sessionId);
}

function cleanupSessions(store) {
  let now = Date.now();
  let ttl = store.ttlMs;
  let keys = Object.keys(store.sessions);
  let cleaned = {
    contents: 0
  };
  keys.forEach(id => {
    let session = store.sessions[id];
    if (session !== undefined && now - session.lastAccess > ttl) {
      Stdlib_Dict.$$delete(store.sessions, id);
      cleaned.contents = cleaned.contents + 1 | 0;
      return;
    }
  });
  if (cleaned.contents <= 0) {
    return;
  }
  let ctx = {};
  ctx["count"] = cleaned.contents;
  log(0, "Sessions cleaned up", ctx);
}

function nextEventId(session) {
  session.eventCounter = session.eventCounter + 1 | 0;
  return session.id + "-" + session.eventCounter.toString();
}

function getSessionStats(store) {
  let result = {};
  result["activeSessions"] = Object.keys(store.sessions).length;
  return result;
}

function formatSSEEvent(data, eventId) {
  let event = "event: message\ndata: " + JSON.stringify(data) + "\n";
  let event$1 = eventId !== undefined ? event + "id: " + eventId + "\n" : event;
  return event$1 + "\n";
}

function createSSEStream() {
  let encoder = new TextEncoder();
  let controllerRef = {
    contents: undefined
  };
  let stream = new ReadableStream({
    start: controller => {
      controllerRef.contents = Primitive_option.some(controller);
    }
  });
  let send = (data, eventId) => {
    let controller = controllerRef.contents;
    if (controller === undefined) {
      return;
    }
    let event = formatSSEEvent(data, eventId);
    Primitive_option.valFromOption(controller).enqueue(encoder.encode(event));
  };
  let closeStream = () => {
    let controller = controllerRef.contents;
    if (controller !== undefined) {
      Primitive_option.valFromOption(controller).close();
      return;
    }
  };
  return {
    stream: stream,
    send: send,
    close: closeStream
  };
}

let defaultOptions = {
  path: "/mcp",
  allowedOrigins: undefined,
  enableCors: true,
  sessionTtlMs: 1800000,
  requestTimeoutMs: 30000,
  enableRateLimiting: true,
  rateLimitWindowMs: 60000,
  rateLimitMaxRequests: 100,
  enableCircuitBreaker: true
};

function makeTransport(optionsOpt, param) {
  let options = optionsOpt !== undefined ? optionsOpt : defaultOptions;
  return {
    options: options,
    sessions: makeSessionStore(options.sessionTtlMs, undefined),
    circuitBreaker: makeCircuitBreaker(undefined, undefined, undefined, undefined),
    rateLimiter: makeRateLimiter(options.rateLimitWindowMs, options.rateLimitMaxRequests, undefined),
    messageHandler: undefined,
    closeHandler: undefined
  };
}

function onMessage(transport, handler) {
  transport.messageHandler = handler;
}

function onClose(transport, handler) {
  transport.closeHandler = handler;
}

function jsonResponse(transport, data, statusOpt, sessionIdOpt) {
  let status = statusOpt !== undefined ? statusOpt : 200;
  let sessionId = sessionIdOpt !== undefined ? Primitive_option.valFromOption(sessionIdOpt) : undefined;
  let headers = {};
  headers["Content-Type"] = "application/json";
  headers["MCP-Protocol-Version"] = protocolVersion;
  if (sessionId !== undefined) {
    headers["Mcp-Session-Id"] = sessionId;
  }
  if (transport.options.enableCors) {
    headers["Access-Control-Allow-Origin"] = "*";
    headers["Access-Control-Allow-Headers"] = "Content-Type, Mcp-Session-Id, MCP-Protocol-Version, Accept";
    headers["Access-Control-Expose-Headers"] = "Mcp-Session-Id, MCP-Protocol-Version";
  }
  return new Response(JSON.stringify(data), {
    status: status,
    headers: headers
  });
}

function acceptedResponse(transport, sessionIdOpt) {
  let sessionId = sessionIdOpt !== undefined ? Primitive_option.valFromOption(sessionIdOpt) : undefined;
  let headers = {};
  headers["MCP-Protocol-Version"] = protocolVersion;
  if (sessionId !== undefined) {
    headers["Mcp-Session-Id"] = sessionId;
  }
  if (transport.options.enableCors) {
    headers["Access-Control-Allow-Origin"] = "*";
  }
  return new Response(null, {
    status: 202,
    headers: headers
  });
}

function sseResponse(transport, session, messages) {
  let sse = createSSEStream();
  messages.forEach(msg => sse.send(msg, nextEventId(session)));
  sse.close();
  let headers = {};
  headers["Content-Type"] = "text/event-stream";
  headers["Cache-Control"] = "no-cache";
  headers["Mcp-Session-Id"] = session.id;
  headers["MCP-Protocol-Version"] = protocolVersion;
  if (transport.options.enableCors) {
    headers["Access-Control-Allow-Origin"] = "*";
    headers["Access-Control-Expose-Headers"] = "Mcp-Session-Id, MCP-Protocol-Version";
  }
  return new Response(null, {
    status: 200,
    headers: headers
  });
}

function corsResponse(transport, request, statusOpt, extraHeadersOpt) {
  let status = statusOpt !== undefined ? statusOpt : 200;
  let extraHeaders = extraHeadersOpt !== undefined ? extraHeadersOpt : ({});
  if (transport.options.enableCors) {
    let o = request.headers.get("Origin");
    let origin = (o == null) ? "*" : o;
    extraHeaders["Access-Control-Allow-Origin"] = origin;
    extraHeaders["Access-Control-Allow-Methods"] = "GET, POST, DELETE, OPTIONS";
    extraHeaders["Access-Control-Allow-Headers"] = "Content-Type, Mcp-Session-Id, MCP-Protocol-Version, Accept, Last-Event-ID";
    extraHeaders["Access-Control-Expose-Headers"] = "Mcp-Session-Id, MCP-Protocol-Version";
    extraHeaders["Access-Control-Max-Age"] = "86400";
  }
  return new Response(null, {
    status: status,
    headers: extraHeaders
  });
}

function errorResponse(transport, message, status) {
  let data = {};
  data["error"] = message;
  return jsonResponse(transport, data, status, undefined);
}

function getHealth(transport) {
  let match = transport.circuitBreaker.state;
  let status;
  switch (match) {
    case "Open" :
      status = "degraded";
      break;
    case "Closed" :
    case "HalfOpen" :
      status = "healthy";
      break;
  }
  let result = {};
  result["status"] = status;
  result["circuitBreaker"] = getCircuitState(transport.circuitBreaker);
  result["sessions"] = getSessionStats(transport.sessions);
  return result;
}

export {
  protocolVersion,
  LogLevel,
  currentLogLevel,
  setLogLevel,
  log,
  makeCircuitBreaker,
  canExecute,
  recordSuccess,
  recordFailure,
  getCircuitState,
  makeRateLimiter,
  isAllowed,
  cleanupRateLimiter,
  makeSessionStore,
  createSession,
  getSession,
  deleteSession,
  cleanupSessions,
  nextEventId,
  getSessionStats,
  formatSSEEvent,
  createSSEStream,
  defaultOptions,
  makeTransport,
  onMessage,
  onClose,
  jsonResponse,
  acceptedResponse,
  sseResponse,
  corsResponse,
  errorResponse,
  getHealth,
}
/* No side effect */
